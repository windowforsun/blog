--- 
layout: single
classes: wide
title: "[Kafka] "
header:
  overlay_image: /img/kafka-bg.jpg
excerpt: ''
author: "window_for_sun"
header-style: text
categories :
  - Kafka
tags:
    - Practice
    - Kafka
toc: true
use_math: true
---  

## Kafka Streams Versioned State Store
`Kafka Streams` 는 기본적으로 오프셋 순서대로 데이터를 처리한다. 
만약 일련의 이유로 데이터의 순서가 뒤바뀐 경우, 오프셋 기준 순서는 타임스탬프의 기준과 순서가 달라지게 된다. 
그러므로 기존에는 이런 타임스탬프 순으로 데이터 스트림을 처리가 필요한 비지니스에서는 주의가 필요했다. 
`Apache Kafka 3.5` 부터는 `Kafka Streams` 에 버전 관리 상태 저장소(`Versioned State Store`)가 도입되어, 
타임스탬프 기준 순서가 중요할 때 크게 활용 할 수 있다.  

`Versioned State Store` 는 아래와 같은 주요 특징이 있다. 

- 타임스탬프 기반 조회 : 버전된 상태 저장소는 특정 시점에 데이터가 어떤 상태였는지를 조회할 수 있다. 이는 과거 데이터를 분석하거나 특정 시점의 상태로 롤백하는 데 유용할 수 있다. 
- 다중 버전 관리 : 동일한 키에 대해 시간에 따라 변하는 여러 버전을 저장할 수 있다. 
- 기록 보존 기간(`Retention Period`) : 버전된 상태 저장소는 각 데이터 버전을 특정 기간 동인 유지한다. 이 기간이 지나면 해당 버전은 자동으로 삭제된다. 이런 기록 보존 기간은 저장소를 생성할 때 설정 가능하다. 
- 성능 : 기존 상태 저장소와 달리 여러 버전을 저장하고 관리하기 때문에, 성능은 비버전 저장소보다 다소 낮을 수 있다. 하지만 최신 데이터는 별도의 저장소에 관리되므로 조회 시 성능저하가 크지 않다.  


### Un-Versioned Stream-Table Join
먼저 `Un-Versioned State Store` 를 사용 했을 때 발생 할 수 있는 문제점에 대해 알아본다. 
이를 설명하기 위해 식당 주문 시스템을 예로 든다. 
시당 메뉴 가격의 변동은 `price-topice` 을 통해 가격 테이블로 만들어진다. 
그리고 고객의 주문읜 `order-topic` 을 통해 주문 스트름이 생성되고, 
고객 주문이 들어오면 주문 스트림과 가격 테이블을 조인해 최종 가격이 계산되는 방식이다. 
예시 구현을 위해서 `price-topic` 은 `key:메뉴,value:가격` 과 같은 구성이고, 
`order-topic` 은 `key:메뉴,value:고객명-수량` 과 같은 구성이다. 
이러한 메시지 구조에서 키를 기준으로 조인을 수행해 해당 고객의 최종 가격을 알아낸다.  

.. 그림 ..

위 처럼 타임스탬프를 신경쓰지 않는 경우에는 식당 주문 시스템의 스트림 처리는 아무 문제 없다. 
이제 타임스템프 정보를 추가해서 순서가 꼬이는 상황을 가정하면 아래와 같다.  

.. 그림 ..

`t=0` 시점에 `pizza` 의 가격은 `8` 이기 때문에 `t=1` 에 들어온 `Anna` 의 `pizza` 2개 주문은 총 `16` 이 된다. 
그리고 `t=4` 에 `pizza` 의 가격이 `10` 으로 인상되고, `Ben` 이 `t=5` 에 주문한 1개 주문은 정상적으로 `10` 으로 계산 된다. 
하지만 `Casandra` 의 `t=3` 의 주문이 문제로 `pizza` 의 가격이 `10` 으로 인상이 처리된 다음에 메시지가 전달된다. 
이 경우 `Un-Versioned State Store` 은 `pizza` 의 가격이 이미 `10` 으로 업데이트가 된 상태이므로, 
가격 인상은 `t=4` 에 이뤄지고 주문은 가격 인상 이전인 `t=3` 에 이뤄졌더라도 이전 가격정보가 없기 때문에 `24` 가 아닌 `30` 으로 계산되는 문제가 발생한다.  

앞선 예시는 단순한 식당의 주문이지만 시간에 따라 가격이 계속해서 변하는 주식과 같은 비지니스에서는 위와 같은 문제는 매우 심각한 상황일 것이다.  

### Versioned State Store
`Versioned State Store` 는 이런 문제를 바로 해결할 수 있다. 
각 키에 대한 여러 버전의 레코드를 저장하고 저장된 각 레코드 버전은 관련 값과 타임스템프 정보가 있다. 
그리고 각 키의 가장 최신 값을 조회하는 일반적인 `get(key)` 외에도, 
`Versioned KeyValue Store` 는 `get(key, asOfTimestamp)` 라는 타임스탬프기반 조회 메서드를 지원하여, 
해당 타임스탬프에 활성화된 레코드 버전을 반환한다.  

.. 그림 ..

`Versioned State Store` 의 각 레코드는 버전과 관련된 `validFrom` 타임스탬프와 `validTo` 라는 타임스탬프 2개가 존재한다. 
`validFrom` 은 해당 레코드의 타임스탬프이고, `validTo` 타임스탬프는 해당 레코드의 다음 버전 레코드의 타임스탬프이다. 
만약 현재 레코드가 가장 최신 레코드라면 `undefined/infinity` 와 같이 설정된다. 
이러한 버전 관련 타임스탬프정보를 바탕으로 레코드 버전의 유효 기간을 정의하고, 
특정 타임스탬프에 활성화된 레코드를 명시적으로 파악해 결과를 내어줄 수 있다. 
이러한 연산은 앞서 언급한 `get(key, asOfTimestamp)` 에서 수행된다.  

인프라의 자원은 유한하기 때문에 무한한 스트림의 모든 버전을 상태 저장소에 저장할 수는 없다. 
그래서 `Versioned State Store` 를 생성할 때는 보존 기간인 `History Retention` 를 필수적으로 설정해야 한다.  

위 그림에서 `History Retention` 는 `30` 이고 현재 스트림의 시간은 `t=63` 인 상태이다. 
현 시점을 기준으로는 `t=60`, `t=50` 그리고 최소 `t=33` 의 시간까지 타임스탬프 조회가 유효하다. 
이는 `현재 스트림 시간(63) - 히스토리 보존 기간(30) = 33` 보다 같거나 크기 때문이다. 
그리고 `t=33` 으로 조회하면 히스토로 보존 기간 밖에 있는 `t=17` 에 업데이트된 레코드를 반환한다는 점을 기억해야 한다. 
이는 `t=33` 시점에 유효한 레코드가 `t=17` 이기 때문에 `Versioned State Store` 는 필요한 버전을 충분히 유지한다.  

하지만 `t=30` 으로 조회하는 경우 `null` 을 반환한다. 
이는 `t=30` 은 히스토리 보존 기간을 벗어났기 때문이다. 
즉 이는 `Versioned State Store` 는 히스토리 보존 기간 범위에 있는 시간 조회에 대해서만 레코드를 반환하고, 
그렇지 않은 경우는 앞선 설명과 같이 `null` 을 반환하게 된다. 
그리고 `Versioned State Store` 의 업데이트 또한 히스토리 보존 기간으로 적용된다. 
즉 히스토리 보존 기간보다 오래된 타임스템프의 쓰기 요청은 거부된다.  

